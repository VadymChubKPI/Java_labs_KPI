### 1. Чим інтерфейс `Set` відрізняється від `Collection` та `List`?
- **`Collection`**: Базовий інтерфейс для роботи з усіма колекціями, включаючи методи додавання, видалення, перевірки наявності елементів.
- **`Set`**: Підінтерфейс `Collection`, що не допускає дублікати. Не гарантує збереження порядку елементів.
- **`List`**: Підінтерфейс `Collection`, який допускає дублікати та гарантує порядок додавання елементів.

---

### 2. У чому різниця між `HashSet` і `TreeSet`?
- **`HashSet`**:
  - Використовує хеш-таблицю.
  - Не гарантує збереження порядку елементів.
  - Швидкий доступ до елементів (`O(1)` у середньому).
- **`TreeSet`**:
  - Побудований на дереві (зазвичай червоно-чорному).
  - Зберігає елементи у впорядкованому вигляді.
  - Операції мають складність `O(log n)`.

---

### 3. Що таке хешування, хеш, хеш-код і хеш-функція?
- **Хешування**: Перетворення об’єкта у числове значення (хеш) для оптимізації пошуку чи зберігання.
- **Хеш**: Результат роботи хеш-функції.
- **Хеш-код**: Ціле число, яке повертає метод `hashCode()`.
- **Хеш-функція**: Алгоритм для обчислення хеш-коду.

---

### 4. Якими мають бути властивості хеш-функції?
1. Для одного і того ж об'єкта повертає однаковий хеш-код під час виконання програми.
2. Об'єкти, рівні за `equals()`, мають однакові хеш-коди.
3. Різні об'єкти мають різні хеш-коди (зведення колізій до мінімуму).

---

### 5. Які властивості притаманні гарній хеш-функції?
- **Рівномірний розподіл**: Хеш-коди рівномірно покривають можливий діапазон.
- **Швидкість**: Обчислення хеш-коду не займає багато часу.
- **Мінімум колізій**: Унікальні об'єкти отримують різні хеш-коди.

---

### 6. Які вимоги до об'єктів у `HashSet`?
- Перевизначення `hashCode()` і `equals()` для забезпечення:
  - Об’єкти, які рівні (`equals()` повертає `true`), мають однакові хеш-коди.
  - Об'єкти, які не рівні, бажано мали різні хеш-коди.

---

### 7. Які переваги та недоліки `HashSet` і `TreeSet`?
- **`HashSet`:**
  - **Переваги**: Швидкий доступ (`O(1)` у середньому).
  - **Недоліки**: Порядок елементів не гарантується.
- **`TreeSet`:**
  - **Переваги**: Підтримує впорядкованість.
  - **Недоліки**: Повільніший доступ (`O(log n)`).

---

### 8. Чим відрізняються `size` і `capacity`? Чи може `size` перевищувати `capacity`?
- **`size`**: Кількість елементів у колекції.
- **`capacity`**: Поточна максимальна кількість елементів, яку колекція може зберігати без розширення.
- **Перевищення?**: `size` не може перевищувати `capacity`. Якщо потрібно додати більше елементів, ємність автоматично збільшується.

---

### 9. Що таке `load factor` і як він впливає?
- **`Load factor`**: Співвідношення кількості елементів до максимальної ємності колекції.
- Визначає момент розширення. Наприклад, при `load factor = 0.75` хеш-таблиця збільшується, коли використано 75% ємності.

---

### 10. Що таке асоціативний масив? Чим ключ відрізняється від значення?
- **Асоціативний масив**: Структура даних (`Map`), яка зберігає пари ключ-значення.
- **Ключ**: Унікальний ідентифікатор.
- **Значення**: Дані, які зберігаються у відповідності до ключа.

---

### 11. Чи можуть ключі або значення повторюватись у асоціативному масиві?
- **Ключі**: Унікальні (дублікати не допускаються).
- **Значення**: Можуть повторюватись.

---

### 12. Які ризики зберігання змінюваних об'єктів у `HashSet` чи `HashMap`?
- Якщо змінюється хеш-код об'єкта після додавання:
  - Неможливо знайти об'єкт.
  - Порушується структура даних.

---

### 13. Чи потрібен інтерфейс `Comparable` для роботи з `TreeMap`?
- Так, об’єкти мають реалізовувати `Comparable` або передаватись із компаратором.

---

### 14. Чи потрібен інтерфейс `Comparable` для роботи з `HashMap`?
- Ні, `HashMap` працює на основі хешування, а не порівняння. `Comparable` не впливає на роботу `HashMap`.